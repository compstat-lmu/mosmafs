---
title: "Introduction to MOSMaFS"
author: "Martin Binder"
output:
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Introduction to MOSMaFS}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include = FALSE}
library("parallelMap")
library("ParamHelpers")
library("mlr")
library("mlrCPO")

library("ecr")
library("mosmafs")

library("magrittr")
library("ggplot2")


set.seed(8008135)

options(width = 100)

parallelStartMulticore(show.info = FALSE)

print.list <- function(x) {
  if (all(vlapply(x, is.atomic))) {
    catf("list(%s)",
      collapse(sprintf("%s = %s", names(x),
        vcapply(x, deparse, width.cutoff = 500)), ", "))
  } else {
    NextMethod(x)
  }
}

knitr::opts_chunk$set(
  cache = FALSE,
  collapse = TRUE,
  comment = "#>"
)
```

## Using MOSMaFS

`mosmafs` offers a variety of tools that make it possible to use the [`ecr`](https://github.com/jakobbossek/ecr2) package for multi-objective optimization of mixed parameter spaces. Mixed here means spaces that both include categorical and numeric hyperparameters. The following (a little contrived) example shows how to use these tools.

`mosmafs` crucially depends on the `ecr` package (currently the github-version!), so make sure you have it installed and loaded. Other packages for this example should also be loaded.

```{r, eval = FALSE}
devtools::install_github("jakobbossek/ecr2")
library("ecr")
library("magrittr")
library("ggplot")
library("ParamHelpers")
library("mlr")
library("mlrCPO")
```

## Demo Setup

### Example Operators

To visualise what is going on, we will introduce a few deterministic operators that perform operations that can be easily understood and followed. These will all be mutation operators; recombination operators work the same but are more annoying to visualize.

The **flipflop** operator negates all bits of a binary individuum:

```{r}
mutFlipflop <- makeMutator(
  mutator = function(ind, ...) {
    1 - ind
  }, supported = "binary")

mutFlipflop(c(1, 0, 1))
```

The **cycle** operator cycles through the values of a discrete (`character`) individuum:

```{r}
mutCycle <- makeMutator(
  mutator = function(ind, values) {
    index <- mapply(match, ind, values)
    index <- index %% viapply(values, length) + 1
    mapply(`[[`, values, index)
  }, supported = "custom")

mutCycle(c("a", "x", "z"), values = list(letters))
```

The **plus** operator adds a parametervalue (default one) to the value of an individuum.
```{r}
mutPlus <- makeMutator(
  mutator = function(ind, summand = 1, ...) {
    ind + summand
  }, supported = "custom")

mutPlus(c(1, 2, 3))
```

The **reverse** operator reverses the order of an individuum:
```{r}
mutReverse <- makeMutator(
  mutator = function(ind, ...) {
    rev(ind)
  }, supported = "custom")

mutReverse(c(1, 2, 3))
```

### Example Datasets

The `mosmafs` package comes with a few functions that generate synthetic datasets that can be used for feature selection. The following creates three columns of randomly sampled points in the `[-1, 1]^3` cube and a target column indicating whether each point is a distance greater than 1 away from the origin. Then ten more copies of that task are added, but with permuted rows---effectively giving 30 noise columns. (The piping operator `%>%` from the `magrittr` package is used for parsimonity).

```{r}
task <- create.hypersphere.data(3, 500) %>%
  create.classif.task(id = "sphere") %>%
  task.add.permuted.cols(10)
```

## Mixed Operators

The heart of this package is the `comibine.operators` function that can be used to apply different operators to different parts of the search space; in particular, to different types of search space dimensions. It works by accepting a `ParamSet` (from the [`ParamHelpers`](https://github.com/berndbischl/ParamHelpers) package) that defines the search-space, and operators that define the operators to use on individual parameters.

### Operators for each Parameter

We may have a `ParamSet` with a logical parameter `bin1`, a discrete (but binary) parameter `bin2`, a discrete vector parameter `disc1`, and a numeric parameter `num1`. We define this `ParamSet` using the `pSS` function from the excellent [`mlrCPO`](https://github.com/mlr-org/mlrCPO) package.

```{r}
ps <- pSS(
  bin1: logical,
  bin2: discrete[no, yes],
  disc1: discrete[letters]^3,
  num1: numeric[0, 10])
```

We can now define an operator that uses the `mutFlipflop` operator on both `bin1` and `bin2`, the `mutCycle` operator on `disc1`, and the `mutPlus` operator on `num1`:

```{r}
combo <- combine.operators(ps,
  bin1 = mutFlipflop,
  bin2 = mutFlipflop,
  disc1 = mutCycle,
  num1 = mutPlus)
```

Here we are treating `bin2` as a binary parameter, so we have to leave the `.binary.discrete.as.logical` parameter of `combine.operators` as `TRUE`. If we wanted to use the `mutCycle` operation on the `bin2` operator, we would have to tell `combine.operators` to treat it as a discrete parameter:

```{r}
combo2 <- combine.operators(ps,
  bin1 = mutFlipflop,
  bin2 = mutCycle,
  disc1 = mutCycle,
  num1 = mutPlus,
  .binary.discrete.as.logical = FALSE)
```

Both these operators do essentially the same: They flip / cycle the binary and discrete parameters, and increase the numeric parameter by one.

```{r}
combo(list(bin1 = TRUE, bin2 = "no", disc1 = c("a", "x", "z"), num1 = 3))

combo2(list(bin1 = TRUE, bin2 = "no", disc1 = c("a", "x", "z"), num1 = 3))
```

### Operators for Parameter Types and Groups

Especially with larger parameter spaces it may be more desirable to define operations not for each parameter individually, but for groups of parameters. Groups can be declared by setting the special `.params.<GROUPNAME>` value to a `character` vector of parameter values to combine into a group. The special groups `numeric`, `logical`, `integer`, and `discrete` are pre-defined and group all parameters of a type that are not otherwise given an operator.

```{r}
combo.group <- combine.operators(ps,
  .params.group1 = c("bin1", "bin2"),
  group1 = mutFlipflop,
  discrete = mutCycle,
  num1 = mutPlus)
```

```{r}
combo.group(list(bin1 = TRUE, bin2 = "no", disc1 = c("a", "x", "z"), num1 = 3))
```

When parameters are put in a group, they are passed to the underlying operators as a vector. This may make a difference if operations depend on the global state of a vector and don't just operate component-wise. This can be shown with the `mutReverse` operator, when given for a group vs. when given for parameters individually:

```{r}
combo.rev.indiv <- combine.operators(ps,
  bin1 = mutReverse,
  bin2 = mutReverse,
  discrete = mutCycle,
  num1 = mutPlus)

combo.rev.group <- combine.operators(ps,
  .params.group1 = c("bin1", "bin2"),
  group1 = mutReverse,
  discrete = mutCycle,
  num1 = mutPlus)
```

When applied to `bin1` and `bin2` individually, the `mutReverse` operator does not change the values:
```{r}
combo.rev.indiv(list(bin1 = TRUE, bin2 = "no", disc1 = c("a", "x", "z"), num1 = 3))
```
However, when they are in a group, the values of `bin1` and `bin2` are combined as a vector and given to `mutReverse`. The `TRUE` value is given as value `1`, the `"no"` value is given as value `0`. They are swapped, and the return list contains `bin1 = FALSE` and `bin2 = "yes"`:
```{r}
combo.rev.group(list(bin1 = TRUE, bin2 = "no", disc1 = c("a", "x", "z"), num1 = 3))
```

Because of this, it is **usually a bad idea** to combine parameters of different types into a single group. Discrete parameters (non-binary discrete parameters if `.binary.discrete.as.logical` is `TRUE`) can not be grouped together with other types of parameters.

### Strategy Parameters

A further extension offered by the `combine.operators` function is the ability to use "strategy parameters". These make it is possible to have the effect of an operator be dependent on the individuals involved. To do this, a `.strategy.<PARAMETER/GROUPNAME>` value must be given, which should be a function that gets the individuum as input, and returns a named list of function parameters as output. This named list is added to the configuration of the operator associated with `<PARAMETER>` or `<GROUPNAME>`.
  
One could, for example, make the `summand` parameter of the `mutPlus` operation dependent on the `bin2` value: If it is `"yes"`, it adds a value, if it is `"no"` it subtracts a value.

```{r}
combo.strategy <- combine.operators(ps,
  logical = mutFlipflop,
  discrete = mutCycle,
  numeric = mutPlus,
  .strategy.numeric = function(ind) {
    if (ind$bin2 == "yes") {
      return(list(summand = 1))
    } else {
      return(list(summand = -1))
    }
  })
```

```{r}
combo.strategy(list(bin1 = TRUE, bin2 = "yes", disc1 = c("a", "x", "z"), num1 = 3))

combo.strategy(list(bin1 = TRUE, bin2 = "no", disc1 = c("a", "x", "z"), num1 = 3))
```

Note how the value of `ind$bin2` from *before* the `mutFlipflop` operation is used: The value that counts is always the input value given to the operator. It is therefore possible to use the values as strategy parameters for their own mutation.

### Recombination Operators

Recombination operators can be combined in the same way that mutation operators can be. The input to a recombination operator is usually a list with two individuals, so the input to the strategy parameter function is also a list with two vectors. This function has to decide whether to construct a strategy depending to one of these individuals, or whether to combine their values, for example averaging them.

### Mixed Operator Individuals

When using the `ecr` package with its vanilla operators, individuals are usually vectors of numbers, for example 0-1-vectors for binary individuals, or `numeric` values for continuous valued individuals. When using mixed operators, the individuals have to be *named lists*, with names and types corresponding to the `ParamSet` given to `combine.operators`. The supported `Param` types, and the expected entries in the individual lists, are the following:

| Parameter Construction (`ParamHelpers`)       | `pSS()` sugar | Type Expected       |
|---                                            |---            |---                  |
| `makeNumericParam`/`makeNumericVectorParam`   | `numeric[, ]` | `numeric`           |
| `makeIntegerParam`/`makeIntegerVectorParam`   | `integer[, ]` | (integer) `numeric` |
| `makeLogicalParam`/`makeLogicalVectorParam`   | `logical`     | `logical`           |
| `makeDiscreteParam`/`makeDiscreteVectorParam` | `discrete[]`  | `character`         |

The only possible surprise here is that individuals must have "`character`" entries for discrete parameters^[In particular, they must have entries corresponding to the **names** of the possible values of a discrete parameter. Consider the `ParamSet` `makeParamSet(makeDiscreteParam("fn", values = list(a = identity, b = exp)))`. An individuum corresponding to this `ParamSet` would have to be one of `list(fn = "a")` or `list(fn = "b")`.]. That means, no `factor` entries, and no lists of characters for `makeDiscreteVectorParam` types.

One can use the `sampleValue` function from the `ParamHelpers` package to generate valid, randomly sampled individuals to use with combined operators. The `discrete.names` option must be set to `TRUE` for that:

```{r}

value <- sampleValue(ps, discrete.names  = TRUE)

print(value)

combo(value)
```

## GA Application

### First Steps

Having a way to use mutation and recombination operators for mixed type individuals is already a big step towards using the `ecr` package for simultaneous model and feature selection ("SMaFS"). It is still necessary to define the actual objective, for which we need a `Learner`, a `Task`, as well as a hyperparameter space to optimize over.

In this example, we choose to optimize the `"classif.rpart"` learner from the `rpart` package, on the `task` defined [above](#example-datasets).

```{r}
lrn <- makeLearner("classif.rpart", maxsurrogate = 0)
```

The parameter set we optimize over is the following:

```{r}
ps.simple <- pSS(
  maxdepth: integer[1, 30],
  minsplit: integer[2, 30],
  cp: numeric[0.001, 0.999],
  selector.selection: logical^getTaskNFeats(task))
```

Notably we have included the parameter `selector.selection`, which controls what features are selected.

We are using some standard mutation and recombination operators for the parameters: Gaussian and rounded-gaussian mutation for numeric parameters, random bitflip for `selector.selection`, and generally uniform crossover mutation. We use the `ecr::setup` method to set hyperparameters of some mutation operators.

```{r}
mutator.simple <- combine.operators(ps.simple,
  numeric = ecr::setup(mutGauss, sdev = 0.1),
  integer = ecr::setup(mutGaussInt, sdev = 3),
  selector.selection = mutBitflip)

crossover.simple <- combine.operators(ps.simple,
  numeric = recPCrossover,
  integer = recPCrossover,
  selector.selection = recPCrossover)
```

The initial population to sample over can be generated using the `ParamHelpers` function `sampleValues()`. Note that by generating an initial population of a certain size (64 here), we implicitly determine the ECR hyperparameter `mu` of individuals in a generation.

```{r}
initials.simple <- sampleValues(ps.simple, 64, discrete.names = TRUE)
```

This is all that is necessary, and it can be used to call the `ecr()` function in the `ecr` package. The `mosmafs` package comes with a useful interface that sets some defaults: `mosmafs.nsga2()`. The run time, 10 generations, would probably be to short for serious applications, but should be enough for demonstration purposes.

```{r}
run.simple <- mosmafs.nsga2(
  fitness.fun = makeObjective(lrn, task, ps.simple, cv5),
  initial.solutions = initials.simple,
  lambda = 32,
  mutator = mutator.simple,
  recombinator = crossover.simple,
  log.pop = TRUE,
  terminators = list(stopOnIters(10)))
```

There is a multitude of methods for analysing and plotting the result. The following plots the succession of pareto fronts for each generation:

```{r, fig.width = 6, fig.height = 5}
plot_fronts <- function(run) {
  fronts <- fitnesses(run, function(x) paretoEdges(x, c(1, 1)))
  ggplot(data = fronts, aes(x = perf, y = propfeat, color = ordered(iter))) +
    geom_line() +
    geom_point(data = fronts[fronts$point, ], shape = "x", size = 5) +
    xlim(0, 1) +
    ylim(0, 1) +
    coord_fixed()
}

plot_fronts(run.simple)
```

### Filter Values as Strategy Parameters

It is possible to use "Feature Filter" values from `mlr` feature filters to heuristically guide mutation of the `selector.selection` bitvector. For this, the filter matrix can be generated using the `makeFilterMat` function, with a few features we choose. (The github-version of `mlr` needs to be installed for this: `devtools::install_github("mlr-org/mlr")`). For demonstration purposes, this contains the useless-in-this-case `"variance"` Filter that just measures each feature's variance. (To use the relatively good `"praznik_JMI"` filter it is necessary to install the github-version of `mlr`, e.g. by using `devtools::install_github("mlr-org/mlr")`).

```{r}
filters <- c("praznik_JMI", "auc", "anova.test", "variance")
fima <- makeFilterMat(task, filters = filters)
```

We now create a `ParamSet` that includes one strategy parameter "`filterweights`", which puts weights on the filter values and thereby controls how strong each one influences the mutation:

```{r}
ps.strat <- pSS(
  maxdepth: integer[1, 30],
  minsplit: integer[2, 30],
  cp: numeric[0.001, 0.999],
  selector.selection: logical^getTaskNFeats(task),
  filterweights: numeric[0.001, 0.999]^length(filters))
```

The mutation operator must now include information on how to use the strategy parameter. Instead of writing out the function, we are using the helper `makeFilterStrategy` that is designed out for this usecase:
```{r}
mutator.strat <- combine.operators(ps.strat,
  numeric = ecr::setup(mutGauss, sdev = 0.1),
  integer = ecr::setup(mutGaussInt, sdev = 3),
  selector.selection = mutUniformMetaReset,
  .strategy.selector.selection = makeFilterStrategy(
    reset.dists = fima, weight.param.name = "filterweights"))
```
We are going to use the same crossover operator as before, but we have to construct it with the new `ParamSet`:
```{r}
crossover.strat <- combine.operators(ps.strat,
  numeric = recPCrossover,
  integer = recPCrossover,
  selector.selection = recPCrossover)
```

The initial population we sample again using the `ParamHelpers` function `sampleValues()`. We are then sampling the `$selector.selection` part again from the equilibrium-distribution of `mutUniformMetaReset`:

```{r}
initials.strat <- sampleValues(ps.strat, 62, discrete.names = TRUE) %>%
  lapply(function(x) {
    x$selector.selection %<>% as.numeric %>%
      mutUniformMetaReset(p = 1,
        reset.dists = fima,
        reset.dist.weights = x$filterweights) %>%
      as.logical
    x
  })
```

These are all preparations needed for a heuristic-backed NSGA2 fun for feature-selection:
```{r}
run.strat <- mosmafs.nsga2(
  fitness.fun = makeObjective(lrn, task, ps.strat, cv5),
  initial.solutions = initials.strat,
  lambda = 32,
  mutator = mutator.strat,
  recombinator = crossover.strat,
  log.pop = TRUE,
  terminators = list(stopOnIters(10)))
```

The pareto-fronts of this run look as follows:
```{r, fig.width = 6, fig.height = 5}
plot_fronts(run.strat)
```
