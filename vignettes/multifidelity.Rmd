---
title: "Multi-Fidelity MOSMaFS"
author: "Martin Binder"
output:
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Introduction to MOSMaFS}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include = FALSE}
library("parallelMap")
library("ParamHelpers")
library("mlr")
library("mlrCPO")

library("ecr")
library("mosmafs")

library("magrittr")
library("ggplot2")


set.seed(8008135)

options(width = 100)
cores <- parallel::detectCores()
if (Sys.getenv("FASTVIGNETTE") != "true") {
  cores <- min(cores, 2)
}
if (.Platform$OS.type == "windows") {
  parallelStartSocket(cores, show.info = FALSE)
} else {
  parallelStartMulticore(cores, show.info = FALSE, mc.set.seed = FALSE)
}

print.list <- function(x) {
  if (all(vlapply(x, is.atomic))) {
    catf("list(%s)",
      collapse(sprintf("%s = %s", names(x),
        vcapply(x, deparse, width.cutoff = 500)), ", "))
  } else {
    NextMethod(x)
  }
}

knitr::opts_chunk$set(
  cache = FALSE,
  collapse = TRUE,
  comment = "#>"
)
```

## Preparation

This vignette starts where the previous vignette leaves off and expects the following preparation:

```{r, eval = FALSE}
devtools::install_github("jakobbossek/ecr2")
library("ecr")
library("magrittr")
library("ggplot")
library("ParamHelpers")
library("mlr")
library("mlrCPO")
```
```{r}
task <- create.hypersphere.data(3, 500) %>%
  create.classif.task(id = "sphere") %>%
  task.add.permuted.cols(10)

lrn <- makeLearner("classif.rpart", maxsurrogate = 0)

ps.simple <- pSS(
  maxdepth: integer[1, 30],
  minsplit: integer[2, 30],
  cp: numeric[0.001, 0.999],
  selector.selection: logical^getTaskNFeats(task))

mutator.simple <- combine.operators(ps.simple,
  numeric = ecr::setup(mutGauss, sdev = 0.1),
  integer = ecr::setup(mutGaussInt, sdev = 3),
  selector.selection = mutBitflip)

crossover.simple <- combine.operators(ps.simple,
  numeric = recPCrossover,
  integer = recPCrossover,
  selector.selection = recPCrossover)

initials <- sampleValues(ps.simple, 64, discrete.names = TRUE)
```

## Multi-Fidelity

In its current state, `mosmafs` supports two ways of performing multi-fidelity optimization: Selected by generation, and selected by dominance. Multi-fidelity by generation is simply performed by changing the fidelity of the objective function after a given number of generations. Multi-fidelity by dominance is performed by evaluating a point with low fidelity first, and then enabling high fidelity if the first evaluation suggests that the point is not dominated by any previous result.

## Fidelity Argument

An objective function optimized with `slickEcr` may have a `fidelity` argument which should choose the fidelity at which the function is evaluated. It can take any numeric value chosen (at another point) by the user, but it should make sense to take a weighted mean of results by this fidelity:
```
(obj(x, fidelity = a) * a + obj(x, fidelity = b) * b) / (a + b)
```

A sensible usage of fidelity is to choose the number of resampling iterations through it.

The `makeObjective` function will create a multi-fidelity compatible objective function if its `resampling` argument is a function, mapping from `numeric(1)` to a resampling object. The results for different fidelities should usually not be subsets of one another, because the evaluation for different fidelities is sometimes averaged over, which can lead to over-emphasis of some resampling folds.
```{r}
nRes <- function(n) {
  makeResampleDesc("Subsample", split = 0.9, iters = n)
}
```

We can use this function to create a multi-fidelity fitness function:
```{r}
fitness.fun <- makeObjective(lrn, task, ps.simple, nRes)

formals(fitness.fun)
```

## Generation-Wise Multi-Fidelity

The `slickEcr` function accepts the `fidelity` argument, which must a `data.frame` with two or three columns. For generation-wise multi-fidelity, we give it a `data.frame` with two columns, with the first column indicating the generation at which a certain fidelity should be used, and the second column containing the fidelity to use. To use fidelity `1` for the first five generations, then fidelity `3`, for another five generations, and finally `5` for the last five, the `data.frame` would be
```{r}
fidelity <- data.frame(
    c(1, 6, 11),
    c(1, 3, 5))
```

This is given to `slickEcr`:
```{r, include = FALSE}
set.seed(3)
```
```{r}
run.gen.mufi <- slickEcr(
    fitness.fun = fitness.fun,
    lambda = 32,
    population = initials,
    mutator = mutator.simple,
    recombinator = crossover.simple,
    generations = 15,
    fidelity = fidelity)
```

The plot of resulting pareto-fronts notably has later generation's pareto fronts seemingly dominated by individuals from earlier generations. This is because in the log-object, the fitness of the first generations was evaluated using the low fidelity of these generations. In later generations, these points were re-evaluated using the larer fidelity.
```{r, fig.width = 6, fig.height = 5}
plot_fronts <- function(run) {
  fronts <- fitnesses(run, function(x) paretoEdges(x, c(1, 1)))
  ggplot(data = fronts, aes(x = perf, y = propfeat, color = ordered(gen))) +
    geom_line() +
    geom_point(data = fronts[fronts$point, ], shape = "x", size = 5) +
    xlim(0, 1) +
    ylim(0, 1) +
    coord_fixed()
}

plot_fronts(run.gen.mufi)
```

The fidelity that was used for each individuum can be extracted from its `"fidelity"` attribute. The runtime will scale approximately linearly (with an added constant overhead) in this case. The sum of all fidelity options used for each generation can also be inspected using the `log.newinds` logging object--it may represent a proxy for the computational ressources that were used. Note how the generations with changing fidelity are present twice: for re-evaluation with new fidelity, and for ordinary evaluation of new individuals.

```{r}
populations <- getPopulations(run.gen.mufi$log)

ind1.gen1 <- populations[[1]]$population[[1]]
attr(ind1.gen1, "fidelity")
attr(ind1.gen1, "runtime")

ind1.gen7 <- populations[[7]]$population[[1]]
attr(ind1.gen7, "fidelity")
attr(ind1.gen7, "runtime")

ind1.gen15 <- populations[[15]]$population[[1]]
attr(ind1.gen15, "fidelity")
attr(ind1.gen15, "runtime")

getStatistics(run.gen.mufi$log.newinds)
```

## Multi-Fidelity by Dominance

The `slickEcr` `fidelity` argument accepts `data.frames` with three columns in the case that different fidelity should be used for points that lie on the pareto-front than those that, in a first evaluation, are dominated. This can be combined with generation-wise multi-fidelity, but our first example will only have one row. It evaluates simple holdout-resampling for each point, and, if the result seems to be better than previous evaluations with the same number of features, re-does the resampling with ten-times repeated holdout resampling.
```{r}
fidelity <- data.frame(1, 1, 10)
```

```{r, include = FALSE}
set.seed(4)
```
```{r}
run.dom.mufi <- slickEcr(
    fitness.fun = fitness.fun,
    lambda = 32,
    population = initials,
    mutator = mutator.simple,
    recombinator = crossover.simple,
    generations = 15,
    fidelity = fidelity)
```

```{r, fig.width = 6, fig.height = 5}
plot_fronts(run.dom.mufi)
```

The `log.newinds` object will again provide information about the aggregated runtime and fidelity used. Some generations perform more high-fidelity evaluations than others (and consequently have longer runtime).

```{r}
getStatistics(run.dom.mufi$log.newinds)
```

Individual evaluation fidelity can be retrieved, again, from a logged individual's attributes. The following plots the pareto-front of generation 3, and the individuals sampled for generation 4. All individuals sampled with high fidelity lie close to the pareto-front, but some may, after high-fidelity evaluation, have turned out to actually be dominated by the old generation.

```{r, fig.width = 6, fig.height = 5}
gen.i <- 3

stat <- getStatistics(run.dom.mufi$log.newinds)
pop <- getPopulations(run.dom.mufi$log.newinds)
front <- fitnesses(run.dom.mufi, function(x) paretoEdges(x, c(1, 1))) %>%
    subset(gen == gen.i)

ngen.info <- pop[[which(stat$gen == gen.i + 1)]]$population %>%
  sapply(function(x) {
    c(fidelity = attr(x, "fidelity"), fitness = attr(x, "fitness"))
  }) %>%
  t %>%
  as.data.frame

ggplot() +
  geom_line(data = front, aes(x = perf, y = propfeat)) +
  geom_point(data = ngen.info,
    aes(x = fitness.perf, y = fitness.propfeat,
      shape = as.factor(fidelity),
      color = as.factor(fidelity),
      size = 3)) +
  scale_size_identity() +
  guides(colour = guide_legend(override.aes = list(size=3))) +
  xlim(0, 1) +
  ylim(0, 1) +
  coord_fixed()
```


## All of the Above

The two approaches can, of course, be combined. It should be noted that the initial generation, as well as each generation after a fidelity-jump, is evaluated with the "high" fidelity column number. The following, for example, evaluates generation 1 with fidelity 10, generation 6 with fidelity 20, and generation 11 with fidelity 30. In between, new points are evaluated with low fidelity first and then re-evaluated on high-fidelity if they seem to not be dominated by the previous generation. Because of this, fidelity-jumps tend to be relatively computationally expensive and should be done sparingly if at all.

```{r}
fidelity <- data.frame(
    c(1, 6, 11),
    c(1, 3, 5),
    c(10, 20, 30))
```

```{r, include = FALSE}
set.seed(5)
```
```{r}
run.all.mufi <- slickEcr(
    fitness.fun = fitness.fun,
    lambda = 32,
    population = initials,
    mutator = mutator.simple,
    recombinator = crossover.simple,
    generations = 15,
    fidelity = fidelity)
```

```{r, fig.width = 6, fig.height = 5}
plot_fronts(run.all.mufi)
```
